

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyclaw.evolve.clawpack &mdash; PyClaw v0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/jsmath/easy/load.js"></script>
    <link rel="shortcut icon" href="../../../_static/clawicon.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="PyClaw v0.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>

<div style="background-color: #FFFFE8; text-align: left; padding: 10px 10px 15px 15px">
<table>
<tr>
<!--
<td>
&nbsp;
<br>
<a href="http://www.clawpack.org/"><img src="../../../_static/clawlogo.jpg" border="0" alt="Clawpack logo"/></a>
</td>
-->
<td>
<br>
&nbsp;
<br>
<a href
<font size="7"  color="#7F0000"> PyClaw Documentation</font>
<br>
&nbsp;
<br>
</td>
</tr>
</table>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href="http://www.clawpack.org"><font color="#7F0000">Clawpack Webpage</font></a>|&nbsp;</li>
<li><a href="../../../apps.html"><font color="#7F0000">Gallery</font></a>|&nbsp;</li>
<li><a href="../../../index.html"><font color="#7F0000">Contents</font></a>|&nbsp;</li>

          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/clawlogo.jpg" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyclaw.evolve.clawpack</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># encoding: utf-8</span>
<span class="s">r&quot;&quot;&quot;</span>
<span class="s">Module containg the classic Clawpack solvers</span>

<span class="s">This module contains the pure and wrapped classic clawpack solvers.  All </span>
<span class="s">clawpack solvers inherit from the :class:`ClawSolver` superclass which in turn </span>
<span class="s">inherits from the :class:`~pyclaw.evolve.solver.Solver` superclass.  As such, </span>
<span class="s">the only solver classes that should be directly used should be the </span>
<span class="s">dimensionally dependent ones such as :class:`ClawSolver1D`.</span>

<span class="s">:Authors:</span>
<span class="s">    Kyle T. Mandli (2008-09-11) Initial version</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># ============================================================================</span>
<span class="c">#      Copyright (C) 2008 Kyle T. Mandli &lt;mandli@amath.washington.edu&gt;</span>
<span class="c">#</span>
<span class="c">#  Distributed under the terms of the Berkeley Software Distribution (BSD) </span>
<span class="c">#  license</span>
<span class="c">#                     http://www.opensource.org/licenses/</span>
<span class="c"># ============================================================================</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pyclaw.evolve.solver</span> <span class="kn">import</span> <span class="n">Solver</span>

<span class="kn">import</span> <span class="nn">limiters</span>
<span class="kn">import</span> <span class="nn">riemann</span>

<span class="c"># ========================================================================</span>
<span class="c">#  User-defined routines</span>
<span class="c"># ========================================================================</span>
<div class="viewcode-block" id="start_step"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.start_step">[docs]</a><span class="k">def</span> <span class="nf">start_step</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Dummy routine called before each step</span>
<span class="s">    </span>
<span class="s">    Replace this routine if you want to do something before each time step.</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="src"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.src">[docs]</a><span class="k">def</span> <span class="nf">src</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">solutions</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">dt</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Dummy routine called to calculate a source term</span>
<span class="s">    </span>
<span class="s">    Replace this routine if you want to include a source term.</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c"># ============================================================================</span>
<span class="c">#  Generic Clawpack solver class</span>
<span class="c"># ============================================================================</span></div>
<div class="viewcode-block" id="ClawSolver"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver">[docs]</a><span class="k">class</span> <span class="nc">ClawSolver</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Generic classic Clawpack solver</span>
<span class="s">    </span>
<span class="s">    All Clawpack solvers inherit from this base class.</span>
<span class="s">    </span>
<span class="s">    .. attribute:: mthlim </span>
<span class="s">    </span>
<span class="s">        Limiter to be used on each wave.  ``Default = [1]``</span>
<span class="s">    </span>
<span class="s">    .. attribute:: order</span>
<span class="s">    </span>
<span class="s">        Order of the solver, either 1 for first order or 2 for second order </span>
<span class="s">        corrections.  ``Default = 2``</span>
<span class="s">    </span>
<span class="s">    .. attribute:: src_split</span>
<span class="s">    </span>
<span class="s">        Whether to use a source splitting method, 0 for none, 1 for first </span>
<span class="s">        order Godunov splitting and 2 for second order Strang splitting.</span>
<span class="s">        ``Default = 0``</span>
<span class="s">        </span>
<span class="s">    .. attribute:: fwave</span>
<span class="s">    </span>
<span class="s">        Whether to split the flux into waves, requires that the Riemann solver</span>
<span class="s">        performs the splitting.  ``Default = False``</span>
<span class="s">        </span>
<span class="s">    .. attribute:: src</span>
<span class="s">    </span>
<span class="s">        Source term function.  Default is the stub function.</span>
<span class="s">    </span>
<span class="s">    .. attribute:: start_step</span>
<span class="s">    </span>
<span class="s">        Function called before each time step is taken.  Default is the stub</span>
<span class="s">        function</span>
<span class="s">        </span>
<span class="s">    </span>
<span class="s">    :Initialization:</span>
<span class="s">    </span>
<span class="s">    Input:</span>
<span class="s">     - *data* - (:class:`~pyclaw.data.Data`) Data object, the solver will look </span>
<span class="s">       for the named variables to instantiate itself.    </span>
<span class="s">    Output:</span>
<span class="s">     - (:class:`ClawSolver`) - Initialized clawpack solver</span>
<span class="s">    </span>
<span class="s">    :Version: 1.0 (2009-06-01)</span>
<span class="s">    &quot;&quot;&quot;</span>
    
    <span class="c"># ========== Generic Init Routine ========================================</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        See :class:`ClawSolver` for full documentation.</span>
<span class="s">        &quot;&quot;&quot;</span>
        
        <span class="c"># Required attributes for this solver</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;mthlim&#39;</span><span class="p">,</span><span class="s">&#39;order&#39;</span><span class="p">,</span><span class="s">&#39;src_split&#39;</span><span class="p">,</span><span class="s">&#39;fwave&#39;</span><span class="p">,</span><span class="s">&#39;src&#39;</span><span class="p">,</span><span class="s">&#39;start_step&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_required_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        
        <span class="c"># Default required attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;mbc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;mthlim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;src_split&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;fwave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;src&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;start_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;kernel_language&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>

        <span class="c"># Call general initialization function</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ClawSolver</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c"># ========== Setup Routine ===============================================</span>
<div class="viewcode-block" id="ClawSolver.setup"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Called before any set of time steps.</span>
<span class="s">        </span>
<span class="s">        This routine will be called once before the solver is used via the</span>
<span class="s">        :class:`~pyclaw.controller.Controller`.  In the case of </span>
<span class="s">        :class:`ClawSolver` we make sure that the :attr:`mthlim` is a list.</span>
<span class="s">        &quot;&quot;&quot;</span>
    
        <span class="c"># Change mthlim to be an array regardless of how long it is</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span><span class="p">]</span>
    
    <span class="c"># ========== Riemann solver library routines =============================   </span></div>
<div class="viewcode-block" id="ClawSolver.list_riemann_solvers"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver.list_riemann_solvers">[docs]</a>    <span class="k">def</span> <span class="nf">list_riemann_solvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        List available Riemann solvers </span>
<span class="s">        </span>
<span class="s">        This routine returns a list of available Riemann solvers which is</span>
<span class="s">        constructed in the Riemann solver package (:ref:`pyclaw_rp`).  In this </span>
<span class="s">        case it lists all Riemann solvers.</span>
<span class="s">        </span>
<span class="s">        :Output:</span>
<span class="s">         - (list) - List of Riemann solver names valid to be used with</span>
<span class="s">           :meth:`set_riemann_solver`</span>
<span class="s">        </span>
<span class="s">        .. note::</span>
<span class="s">            These Riemann solvers are currently only accessible to the python </span>
<span class="s">            time stepping routines.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">rp_solver_list</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c"># Construct list from each dimension list</span>
        <span class="k">for</span> <span class="n">rp_solver</span> <span class="ow">in</span> <span class="n">rp_solver_list_1d</span><span class="p">:</span>
            <span class="n">rp_solver_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_1d&#39;</span> <span class="o">%</span> <span class="n">rp_solver</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rp_solver</span> <span class="ow">in</span> <span class="n">rp_solver_list_2d</span><span class="p">:</span>
            <span class="n">rp_solver_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_2d&#39;</span> <span class="o">%</span> <span class="n">rp_solver</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rp_solver</span> <span class="ow">in</span> <span class="n">rp_solver_list_3d</span><span class="p">:</span>
            <span class="n">rp_solver_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_3d&#39;</span> <span class="o">%</span> <span class="n">rp_solver</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">rp_solver_list</span>
    </div>
<div class="viewcode-block" id="ClawSolver.set_riemann_solver"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver.set_riemann_solver">[docs]</a>    <span class="k">def</span> <span class="nf">set_riemann_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solver_name</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Assigns the library solver solver_name as the Riemann solver.</span>
<span class="s">        </span>
<span class="s">        :Input:</span>
<span class="s">         - *solver_name* - (string) Name of the solver to be used, raises a </span>
<span class="s">           NameError if the solver does not exist.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Cannot set a Riemann solver with this class,&quot;</span> <span class="o">+</span>
                                        <span class="s">&quot; use one of the derived classes.&quot;</span><span class="p">)</span>
         
    <span class="c"># ========== Time stepping routines ======================================</span></div>
<div class="viewcode-block" id="ClawSolver.step"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Evolve solutions one time step</span>

<span class="s">        This routine encodes the generic order in a full time step in this</span>
<span class="s">        order:</span>
<span class="s">        </span>
<span class="s">        1. The :meth:`start_step` function is called</span>
<span class="s">        </span>
<span class="s">        2. A half step on the source term :func:`src` if Strang splitting is </span>
<span class="s">           being used (:attr:`src_split` = 2)</span>
<span class="s">        </span>
<span class="s">        3. A step on the homogeneous problem :math:`q_t + f(q)_x = 0` is taken</span>
<span class="s">        </span>
<span class="s">        4. A second half step or a full step is taken on the source term</span>
<span class="s">           :func:`src` depending on whether Strang splitting was used </span>
<span class="s">           (:attr:`src_split` = 2) or Godunov splitting </span>
<span class="s">           (:attr:`src_split` = 1)</span>

<span class="s">        This routine is called from the method evolve_to_time defined in the</span>
<span class="s">        pyclaw.evolve.solver.Solver superclass.</span>

<span class="s">        :Input:</span>
<span class="s">         - *solutions* - (:class:`~pyclaw.solution.Solution`) Dictionary of </span>
<span class="s">           solutions to be evolved</span>
<span class="s">         </span>
<span class="s">        :Output: </span>
<span class="s">         - (bool) - True if full step succeeded, False otherwise</span>
<span class="s">        &quot;&quot;&quot;</span>

        <span class="c"># Call b4step, pyclaw should be subclassed if this is needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">)</span>

        <span class="c"># Source term splitting, pyclaw should be subclassed if this </span>
        <span class="c"># is needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">,</span><span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    
        <span class="c"># Take a step on the homogeneous problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homogeneous_step</span><span class="p">(</span><span class="n">solutions</span><span class="p">)</span>

        <span class="c"># Putting this here now for PetClaw.  We should think about the best way</span>
        <span class="c"># to handle CFL communication.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">communicateCFL</span><span class="p">()</span>

        <span class="c"># Check here if we violated the CFL condition, if we did, return </span>
        <span class="c"># immediately to evolve_to_time and let it deal with picking a new</span>
        <span class="c"># dt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfl</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfl_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Strang splitting</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">,</span><span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

        <span class="c"># Godunov Splitting</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">,</span><span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">True</span>
            </div>
<div class="viewcode-block" id="ClawSolver.homogeneous_step"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver.homogeneous_step">[docs]</a>    <span class="k">def</span> <span class="nf">homogeneous_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Take one homogeneous step on the solutions</span>
<span class="s">        </span>
<span class="s">        This is a dummy routine and must be overridden.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Dummy routine, please override!&quot;</span><span class="p">)</span>

<span class="c"># ============================================================================</span>
<span class="c">#  ClawPack 1d Solver Class</span>
<span class="c"># ============================================================================</span></div></div>
<div class="viewcode-block" id="ClawSolver1D"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver1D">[docs]</a><span class="k">class</span> <span class="nc">ClawSolver1D</span><span class="p">(</span><span class="n">ClawSolver</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Clawpack evolution routine in 1D</span>
<span class="s">    </span>
<span class="s">    This class represents the 1d clawpack solver on a single grid.  Note that </span>
<span class="s">    there are routines here for interfacing with the fortran time stepping </span>
<span class="s">    routines and the python time stepping routines.  The ones used are </span>
<span class="s">    dependent on the argument given to the initialization of the solver </span>
<span class="s">    (defaults to python).</span>
<span class="s">    </span>
<span class="s">    .. attribute:: rp</span>
<span class="s">    </span>
<span class="s">        Riemann solver function.</span>
<span class="s">        </span>
<span class="s">    :Initialization:</span>
<span class="s">    </span>
<span class="s">    Input:</span>
<span class="s">     - *data* - (:class:`~pyclaw.data.Data`) An instance of a Data object whose</span>
<span class="s">       parameters can be used to initialize this solver</span>
<span class="s">    Output:</span>
<span class="s">     - (:class:`ClawSolver1D`) - Initialized 1d clawpack solver</span>
<span class="s">        </span>
<span class="s">    :Authors:</span>
<span class="s">        Kyle T. Mandli (2008-09-11) Initial version</span>
<span class="s">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Create 1d Clawpack solver</span>
<span class="s">        </span>
<span class="s">        See :class:`ClawSolver1D` for more info.</span>
<span class="s">        &quot;&quot;&quot;</span>   
        
        <span class="c"># Add the functions as required attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;rp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;rp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Import Riemann solvers</span>
        <span class="k">exec</span><span class="p">(</span><span class="s">&#39;import riemann&#39;</span><span class="p">,</span><span class="nb">globals</span><span class="p">())</span>
            
        <span class="nb">super</span><span class="p">(</span><span class="n">ClawSolver1D</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


    <span class="c"># ========== Setup routine =============================   </span>
<div class="viewcode-block" id="ClawSolver1D.setup"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver1D.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        See setup doc string in the super class.</span>
<span class="s">        We are initializing (allocating) the working arrays needed by fortran kernels </span>
<span class="s">        in this routine. These arrays are passed in each call to the fortran kernel step1.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="c"># Grid we will be working on</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># Number of equations</span>
        <span class="n">meqn</span><span class="p">,</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mbc</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">meqn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mwaves</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Fortran&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">meqn</span><span class="p">,</span><span class="n">mx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">meqn</span><span class="p">,</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amdq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">meqn</span><span class="p">,</span><span class="n">mx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apdq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">meqn</span><span class="p">,</span><span class="n">mx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>

    <span class="c"># ========== Riemann solver library routines =============================   </span></div>
<div class="viewcode-block" id="ClawSolver1D.list_riemann_solvers"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver1D.list_riemann_solvers">[docs]</a>    <span class="k">def</span> <span class="nf">list_riemann_solvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        List available Riemann solvers </span>
<span class="s">        </span>
<span class="s">        This routine returns a list of available Riemann solvers which is</span>
<span class="s">        constructed in the Riemann solver package (_pyclaw_rp).  In this case</span>
<span class="s">        it lists only the 1D Riemann solvers.</span>
<span class="s">        </span>
<span class="s">        :Output:</span>
<span class="s">         - (list) - List of Riemann solver names valid to be used with</span>
<span class="s">           :meth:`set_riemann_solver`</span>
<span class="s">        </span>
<span class="s">        .. note::</span>
<span class="s">            These Riemann solvers are currently only accessible to the python </span>
<span class="s">            time stepping routines.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">riemann</span><span class="o">.</span><span class="n">rp_solver_list_1d</span>
    </div>
<div class="viewcode-block" id="ClawSolver1D.set_riemann_solver"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver1D.set_riemann_solver">[docs]</a>    <span class="k">def</span> <span class="nf">set_riemann_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solver_name</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Assigns the library solver solver_name as the Riemann solver.</span>
<span class="s">        </span>
<span class="s">        :Input:</span>
<span class="s">         - *solver_name* - (string) Name of the solver to be used, raises a </span>
<span class="s">           ``NameError`` if the solver does not exist.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">logging</span>
        <span class="k">if</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="n">riemann</span><span class="o">.</span><span class="n">rp_solver_list_1d</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&quot;self.rp = riemann.rp_</span><span class="si">%s</span><span class="s">_1d&quot;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s">&#39;Could not find Riemann solver with name </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">solver_name</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

    <span class="c"># ========== Homogeneous Step =====================================</span></div>
<div class="viewcode-block" id="ClawSolver1D.homogeneous_step"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver1D.homogeneous_step">[docs]</a>    <span class="k">def</span> <span class="nf">homogeneous_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Take one time step on the homogeneous hyperbolic system</span>

<span class="s">        Takes one time step of size dt on the hyperbolic system defined in the</span>
<span class="s">        appropriate Riemann solver rp.</span>

<span class="s">        :Input:</span>
<span class="s">         - *solutions* - (:class:`~pyclaw.solution.Solution`) Solution that </span>
<span class="s">           will be evolved</span>

<span class="s">        :Version: 1.0 (2009-07-01)</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qbc</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">meqn</span><span class="p">,</span><span class="n">maux</span><span class="p">,</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mbc</span><span class="p">,</span><span class="n">aux</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">meqn</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">maux</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mwaves</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">aux</span>
          
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Fortran&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">step1</span> <span class="kn">import</span> <span class="n">step1</span>
            <span class="c"># If the user did not call setup function that allocate date for the</span>
            <span class="c"># fortran call, the function setup will be called in here.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">solutions</span><span class="p">)</span>
            
            <span class="n">local_n</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dx</span><span class="p">,</span><span class="n">dt</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="n">dtdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">local_n</span><span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="n">dx</span>
            <span class="n">maxmx</span> <span class="o">=</span> <span class="n">local_n</span> <span class="o">-</span><span class="n">mbc</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">maxmx</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span> <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="p">(</span><span class="n">maux</span><span class="p">,</span><span class="n">local_n</span><span class="p">)</span> <span class="p">)</span>
        
            <span class="n">method</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c"># hardcoded 7</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_variable</span>  <span class="c"># fixed or adjustable timestep</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>  <span class="c"># order of the method</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># hardcoded 0, case of 2d or 3d</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># hardcoded 0 design issue: contorller.verbosity</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span>  <span class="c"># src term</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">capa</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">method</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  
            <span class="k">else</span><span class="p">:</span>
                <span class="n">method</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  
            <span class="n">method</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">maux</span>  <span class="c"># aux</span>
        
            <span class="n">q</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="n">step1</span><span class="p">(</span><span class="n">maxmx</span><span class="p">,</span><span class="n">mbc</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">aux</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">method</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">amdq</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">apdq</span><span class="p">,</span><span class="n">dtdx</span><span class="p">)</span>

        <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Python&#39;</span><span class="p">):</span>
 
            <span class="c"># Limiter to use in the pth family</span>
            <span class="n">limiter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span><span class="p">,</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
        
            <span class="n">dtdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="o">+</span><span class="n">grid</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>

            <span class="c"># Find local value for dt/dx</span>
            <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">capa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dtdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">capa</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtdx</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">/</span><span class="n">grid</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
            <span class="c"># Solve Riemann problem at each interface</span>
            <span class="n">q_l</span><span class="o">=</span><span class="n">q</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">q_r</span><span class="o">=</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">aux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">aux_l</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">aux</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">aux_r</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">aux</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_l</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">aux_r</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">wave</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">amdq</span><span class="p">,</span><span class="n">apdq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rp</span><span class="p">(</span><span class="n">q_l</span><span class="p">,</span><span class="n">q_r</span><span class="p">,</span><span class="n">aux_l</span><span class="p">,</span><span class="n">aux_r</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">aux_global</span><span class="p">)</span>
            
            <span class="c"># Update loop limits, these are the limits for the Riemann solver</span>
            <span class="c"># locations, which then update a grid cell value</span>
            <span class="c"># We include the Riemann problem just outside of the grid so we can</span>
            <span class="c"># do proper limiting at the grid edges</span>
            <span class="c">#        LL    |                               |     UL</span>
            <span class="c">#  |  LL |     |     |     |  ...  |     |     |  UL  |     |</span>
            <span class="c">#              |                               |</span>
            <span class="n">LL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mbc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">UL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mbc</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> 

            <span class="c"># Update q for Godunov update</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">meqn</span><span class="p">):</span>
                <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span><span class="o">*</span><span class="n">apdq</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">amdq</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
            <span class="c"># Compute maximum wave speed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">mw</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">smax1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">smax2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfl</span><span class="p">,</span><span class="n">smax1</span><span class="p">,</span><span class="n">smax2</span><span class="p">)</span>

            <span class="c"># If we are doing slope limiting we have more work to do</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c"># Initialize flux corrections</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">meqn</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">)</span> <span class="p">)</span>
            
                <span class="c"># Apply Limiters to waves</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">limiter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">wave</span> <span class="o">=</span> <span class="n">limiters</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">meqn</span><span class="p">,</span><span class="n">wave</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">limiter</span><span class="p">,</span><span class="n">dtdx</span><span class="p">)</span>

                <span class="c"># Compute correction fluxes for second order q_{xx} terms</span>
                <span class="n">dtdxave</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwave</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">mw</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">sabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">om</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">sabs</span><span class="o">*</span><span class="n">dtdxave</span><span class="p">[:</span><span class="n">UL</span><span class="o">-</span><span class="n">LL</span><span class="p">]</span>
                        <span class="n">ssign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">meqn</span><span class="p">):</span>
                            <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ssign</span> <span class="o">*</span> <span class="n">om</span> <span class="o">*</span> <span class="n">wave</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">mw</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">sabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">om</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">sabs</span><span class="o">*</span><span class="n">dtdxave</span><span class="p">[:</span><span class="n">UL</span><span class="o">-</span><span class="n">LL</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">meqn</span><span class="p">):</span>
                            <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sabs</span> <span class="o">*</span> <span class="n">om</span> <span class="o">*</span> <span class="n">wave</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">mw</span><span class="p">,</span><span class="n">LL</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c"># Update q by differencing correction fluxes</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">meqn</span><span class="p">):</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dtdx</span><span class="p">[</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">UL</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">LL</span><span class="p">:</span><span class="n">UL</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 

        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unrecognized kernel_language; choose &#39;Fortran&#39; or &#39;Python&#39;&quot;</span><span class="p">)</span>
            
        <span class="n">grid</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">]</span>

   

<span class="c"># ============================================================================</span>
<span class="c">#  ClawPack 2d Solver Class</span>
<span class="c"># ============================================================================</span></div></div>
<div class="viewcode-block" id="ClawSolver2D"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver2D">[docs]</a><span class="k">class</span> <span class="nc">ClawSolver2D</span><span class="p">(</span><span class="n">ClawSolver</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Clawpack evolution routine in 2D</span>
<span class="s">    </span>
<span class="s">    Note that only the fortran routines are supported for now in 2D.</span>
<span class="s">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Create 2d Clawpack solver</span>
<span class="s">        </span>
<span class="s">        See :class:`ClawSolver2D` for more info.</span>
<span class="s">        &quot;&quot;&quot;</span>   
        
        <span class="c"># Add the functions as required attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;rp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_attr_values</span><span class="p">[</span><span class="s">&#39;rp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c"># Import Riemann solvers</span>
        <span class="k">exec</span><span class="p">(</span><span class="s">&#39;import riemann&#39;</span><span class="p">,</span><span class="nb">globals</span><span class="p">())</span>
            
        <span class="nb">super</span><span class="p">(</span><span class="n">ClawSolver2D</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c"># ========== Setup routine =============================   </span>
<div class="viewcode-block" id="ClawSolver2D.setup"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver2D.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        See setup doc string in the super class.</span>
<span class="s">        We are initializing (allocating) the working arrays needed by fortran kernels </span>
<span class="s">        in this routine. These arrays are passed in each call to the fortran kernel dimsp2.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="c"># Grid we will be working on</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># Number of equations</span>
        <span class="n">meqn</span><span class="p">,</span><span class="n">maux</span><span class="p">,</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mbc</span><span class="p">,</span><span class="n">aux</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">meqn</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">maux</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mwaves</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">aux</span>
        <span class="n">maxmx</span><span class="p">,</span><span class="n">maxmy</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">maxm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxmx</span><span class="p">,</span> <span class="n">maxmy</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">narray</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">narray</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="c"># work arround solution</span>
        <span class="k">if</span><span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">maux</span><span class="o">=</span><span class="mi">1</span>

        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Fortran&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">meqn</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fadd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">meqn</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gadd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">meqn</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q1d</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">meqn</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtdx1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtdy1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">maux</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">maux</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">maux</span><span class="p">,</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
            <span class="n">mwork</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxm</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">meqn</span> <span class="o">+</span> <span class="n">mwaves</span> <span class="o">+</span> <span class="n">meqn</span><span class="o">*</span><span class="n">mwaves</span><span class="p">)</span> \
                  <span class="o">+</span> <span class="p">(</span><span class="n">narray</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxmx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxmy</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">)</span> <span class="o">*</span> <span class="n">meqn</span>
            <span class="c"># Amal: I think no need for the term</span>
            <span class="c"># (narray-1) * (maxmx + 2*mbc) * (maxmy + 2*mbc) * meqn</span>
            <span class="c"># this extra q array should be created and handled in function</span>
            <span class="c"># step in case we have src term with strange splitting (Do not</span>
            <span class="c"># think the fortran code will complain, but not sure)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">work</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">mwork</span><span class="p">))</span>

        <span class="c">#Initialize (allocate) memory for work arrays that will be passed to the fortran kernel</span>


    <span class="c"># ========== Riemann solver library routines =============================   </span></div>
<div class="viewcode-block" id="ClawSolver2D.list_riemann_solvers"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver2D.list_riemann_solvers">[docs]</a>    <span class="k">def</span> <span class="nf">list_riemann_solvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        List available Riemann solvers </span>
<span class="s">        </span>
<span class="s">        This routine returns a list of available Riemann solvers which is</span>
<span class="s">        constructed in the Riemann solver package (_pyclaw_rp).  In this case</span>
<span class="s">        it lists only the 1D Riemann solvers.</span>
<span class="s">        </span>
<span class="s">        :Output:</span>
<span class="s">         - (list) - List of Riemann solver names valid to be used with</span>
<span class="s">           :meth:`set_riemann_solver`</span>
<span class="s">        </span>
<span class="s">        .. note::</span>
<span class="s">            These Riemann solvers are currently only accessible to the python </span>
<span class="s">            time stepping routines.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">riemann</span><span class="o">.</span><span class="n">rp_solver_list_1d</span>
    </div>
<div class="viewcode-block" id="ClawSolver2D.set_riemann_solver"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver2D.set_riemann_solver">[docs]</a>    <span class="k">def</span> <span class="nf">set_riemann_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solver_name</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        Assigns the library solver solver_name as the Riemann solver.</span>
<span class="s">        </span>
<span class="s">        :Input:</span>
<span class="s">         - *solver_name* - (string) Name of the solver to be used, raises a </span>
<span class="s">           ``NameError`` if the solver does not exist.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">logging</span>
        <span class="k">if</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="n">riemann</span><span class="o">.</span><span class="n">rp_solver_list_1d</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&quot;self.rp = riemann.rp_</span><span class="si">%s</span><span class="s">_1d&quot;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;solver&#39;</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s">&#39;Could not find Riemann solver with name </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">solver_name</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

    <span class="c"># ========== Homogeneous Step =====================================</span></div>
<div class="viewcode-block" id="ClawSolver2D.homogeneous_step"><a class="viewcode-back" href="../../../sphinx/pyclaw/evolve/clawpack.html#pyclaw.evolve.clawpack.ClawSolver2D.homogeneous_step">[docs]</a>    <span class="k">def</span> <span class="nf">homogeneous_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solutions</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;</span>
<span class="s">        </span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="c"># Grid we will be working on</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># Number of equations</span>
        <span class="n">meqn</span><span class="p">,</span><span class="n">maux</span><span class="p">,</span><span class="n">mwaves</span><span class="p">,</span><span class="n">mbc</span><span class="p">,</span><span class="n">aux</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">meqn</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">maux</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mwaves</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mbc</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">aux</span>


        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Fortran&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">dimsp2</span> <span class="kn">import</span> <span class="n">dimsp2</span>
            <span class="c"># If the user did not call setup function that allocate date for the</span>
            <span class="c"># fortran call, the function setup will be called in here.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qadd</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">solutions</span><span class="p">)</span>
            <span class="n">maxmx</span><span class="p">,</span><span class="n">maxmy</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">maxm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxmx</span><span class="p">,</span> <span class="n">maxmy</span><span class="p">)</span>
            <span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="o">=</span> <span class="n">maxmx</span><span class="p">,</span><span class="n">maxmy</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">aux</span>
            
            <span class="c">#New workaround</span>
            <span class="c">#The following is a hack to work around an issue</span>
            <span class="c">#with f2py.  It involves wastefully allocating a three arrays.</span>
            <span class="c">#f2py seems not able to handle multiple zero-size arrays being passed.</span>
            <span class="c"># it appears the bug is related to f2py/src/fortranobject.c line 841.</span>
            <span class="k">if</span><span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span> 
                <span class="n">maux</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">aux</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">maxmx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">,</span><span class="n">maxmy</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mbc</span><span class="p">))</span>
                
            <span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">dt</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">grid</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

            <span class="n">method</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_variable</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c"># only dimensional splitting for now</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># hardcoded 0 design issue: controller.verbosity</span>
            <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_split</span>  <span class="c"># src term</span>

            <span class="c"># mcapa no longer points to the capa components of the aux </span>
            <span class="c"># array as in fortran. capa now is a separate array.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">capa</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span> <span class="n">method</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">method</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  
            <span class="n">method</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">maux</span>
            
            <span class="n">cflv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">cflv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cfl_max</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cfl_desired</span><span class="p">]</span>
            <span class="c">#cflv[2] and cflv[3] are output values.</span>

            <span class="k">if</span> <span class="n">method</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">narray</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">narray</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">qold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qbc</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">qnew</span> <span class="o">=</span> <span class="n">qold</span> <span class="c">#(input/output)</span>

            <span class="n">q</span><span class="p">,</span> <span class="n">cfl</span> <span class="o">=</span> <span class="n">dimsp2</span><span class="p">(</span><span class="n">maxm</span><span class="p">,</span><span class="n">maxmx</span><span class="p">,</span><span class="n">maxmy</span><span class="p">,</span><span class="n">mbc</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">,</span> \
                      <span class="n">qold</span><span class="p">,</span><span class="n">qnew</span><span class="p">,</span><span class="n">aux</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">method</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mthlim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cfl</span><span class="p">,</span><span class="n">cflv</span><span class="p">,</span> \
                      <span class="bp">self</span><span class="o">.</span><span class="n">qadd</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fadd</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">gadd</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">q1d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dtdx1d</span><span class="p">,</span>\
                      <span class="bp">self</span><span class="o">.</span><span class="n">dtdy1d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">aux1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">aux2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">aux3</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">)</span>


            <span class="bp">self</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="n">cfl</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[:,</span><span class="n">mbc</span><span class="p">:</span><span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">mbc</span><span class="p">,</span><span class="n">mbc</span><span class="p">:</span><span class="n">grid</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">mbc</span><span class="p">]</span>

        <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_language</span> <span class="o">==</span> <span class="s">&#39;Python&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;No python implementation for homogeneous_step in case of 2D.&quot;</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href="http://www.clawpack.org"><font color="#7F0000">Clawpack Webpage</font></a>|&nbsp;</li>
<li><a href="../../../apps.html"><font color="#7F0000">Gallery</font></a>|&nbsp;</li>
<li><a href="../../../index.html"><font color="#7F0000">Contents</font></a>|&nbsp;</li>

          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2011, Kyle Mandli, David I. Ketcheson, Amal Alghamdi, and Aron Ahmadia.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>