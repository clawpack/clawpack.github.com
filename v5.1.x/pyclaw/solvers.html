
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Using PyClaw’s solvers: Classic and SharpClaw &#8212; Clawpack 5.1.0 documentation</title>
    <link rel="stylesheet" href="../_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/layout.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/clawicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Running in parallel" href="parallel.html" />
    <link rel="prev" title="Porting a problem from Clawpack 4.6.x to PyClaw" href="clawpack_and_pyclaw.html" /> 
  </head><body>
<div id="main-wrapper" class="sphinx">
<div id="header-wrapper">
  <section id="header">
    <!-- <h1><a href="http://clawpack.org/">Clawpack</a></h1> -->
    <h1><a href="http://clawpack.org/">Clawpack-5</a></h1> 
    <nav>
      <ul>
        <li>
          <a href="../contents.html">Docs</a>
        </li>
        <li>
          <a href="../installing.html">Install</a>
        </li>
        <li>
          <a class="" href="http://clawpack.org/gallery/index.html">Gallery</a>
        </li>
        <li>
          <a href="../about.html">Citation</a>
        </li>
        <li>
          <a class="active" href="http://github.com/clawpack">GitHub</a>
        </li>
        <li>
          <a class="" href="../community.html">Community</a>
        </li>
        <li>
          <a class="" href="../developers.html">Contribute</a>
        </li>
      </ul>
    </nav>
  </section>
<div class="decoration"></div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="parallel.html" title="Running in parallel"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="clawpack_and_pyclaw.html" title="Porting a problem from Clawpack 4.6.x to PyClaw"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../contents.html">Clawpack 5.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Pyclaw</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="going_further.html" accesskey="U">Going Further</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#using-pyclaw-s-solvers-classic-and-sharpclaw" id="id2">Using PyClaw’s solvers: Classic and SharpClaw</a></p>
<ul>
<li><p><a class="reference internal" href="#sharpclaw-solvers" id="id3">SharpClaw Solvers</a></p>
<ul>
<li><p><a class="reference internal" href="#pyclaw-sharpclaw" id="id4"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.sharpclaw</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pyclaw-classic-clawpack-solvers" id="id5">Pyclaw Classic Clawpack Solvers</a></p>
<ul>
<li><p><a class="reference internal" href="#pyclaw-classic-solver" id="id6"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.classic.solver</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="using-pyclaw-s-solvers-classic-and-sharpclaw">
<span id="solvers"></span><h1><a class="toc-backref" href="#id2">Using PyClaw’s solvers: Classic and SharpClaw</a><a class="headerlink" href="#using-pyclaw-s-solvers-classic-and-sharpclaw" title="Permalink to this headline">¶</a></h1>
<p>At present, PyClaw includes two types of solvers:</p>
<blockquote>
<div><ul class="simple">
<li><p>Classic: the original Clawpack algorithms, in 1/2/3D</p></li>
<li><p>SharpClaw: higher-order wave propagation using WENO reconstruction and
Runge-Kutta integration, in 1/2D</p></li>
</ul>
</div></blockquote>
<p>Solver initialization takes one argument: a Riemann solver, usually
from the Riemann repository.
Typically, all that is needed to select a different solver is to specify
it in the problem script, e.g.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clawpack</span> <span class="kn">import</span> <span class="n">pyclaw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clawpack</span> <span class="kn">import</span> <span class="n">riemann</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">pyclaw</span><span class="o">.</span><span class="n">ClawSolver2D</span><span class="p">(</span><span class="n">riemann</span><span class="o">.</span><span class="n">acoustics_2D</span><span class="p">)</span>
</pre></div>
</div>
<p>for the 2D acoustics equations and the Classic Clawpack solver or</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">pyclaw</span><span class="o">.</span><span class="n">SharpClawSolver2D</span><span class="p">(</span><span class="n">riemann</span><span class="o">.</span><span class="n">acoustics_2D</span><span class="p">)</span>
</pre></div>
</div>
<p>for the SharpClaw solver.  Most of the applications distributed with PyClaw
are set up to use either solver, depending on the value of the command line option
<cite>solver_type</cite>, which should be set to <cite>classic</cite> or <cite>sharpclaw</cite>.</p>
<p>Typically, for a given grid resolution, the SharpClaw solvers are more accurate
but also more computationally expensive.
For typical problems involving shocks, the Classic solvers are recommended.
For problems involving high-frequency waves, turbulence, or smooth solutions,
the SharpClaw solvers may give more accurate solutions at less cost.  This
is an active area of research and you may wish to experiment with both solvers.</p>
<p>Future plans include incorporation of finite-difference and discontinuous Galerkin
solvers.</p>
<p>Key differences between the Classic and SharpClaw solvers are:</p>
<blockquote>
<div><ul class="simple">
<li><p>The source term routine for the Classic solver should return the integral of
the source term over a step, while the source term routine for SharpClaw
should return the instantaneous value of the source term.</p></li>
<li><p>The solvers have different options.  For a list of options and possible
values, see the documentation of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ClawSolver</span></code> and
<a class="reference internal" href="#pyclaw.sharpclaw.solver.SharpClawSolver" title="pyclaw.sharpclaw.solver.SharpClawSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharpClawSolver</span></code></a> classes.</p></li>
</ul>
</div></blockquote>
<div class="section" id="sharpclaw-solvers">
<span id="id1"></span><h2><a class="toc-backref" href="#id3">SharpClaw Solvers</a><a class="headerlink" href="#sharpclaw-solvers" title="Permalink to this headline">¶</a></h2>
<p>The SharpClaw solvers are a collection of solvers that contain the
functionality of the Fortran code SharpClaw, developed in David Ketcheson’s
thesis.  The 1D SharpClaw solver contains a pure Python implementation as
well as a wrapped Fortran version.  The 2D solver is in progress but not
available yet.  The SharpClaw solvers provide an interface similar to that
of the classic Clawpack solvers, but with a few different options.
The superclass solvers are not meant
to be used separately but are there to provide common routines for all the
Clawpack solvers.  Please refer to each of the inherited classes for more info
about the methods and attributes they provide each class.
.. The inheritance structure is:</p>
<dl class="field-list simple">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p>This is a simple example of how to instantiate and evolve a solution to a
later time <span class="math notranslate nohighlight">\(\text{t_end}\)</span> using the 1D acoustics Riemann solver.</p>
</dd>
</dl>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clawpack</span> <span class="kn">import</span> <span class="n">pyclaw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">pyclaw</span><span class="o">.</span><span class="n">SharpClawSolver1D</span><span class="p">()</span>           <span class="c1"># Instantiate a default, 1d solver</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">evolve_to_time</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span><span class="n">t_end</span><span class="p">)</span>  <span class="c1"># Evolve the solution to t_end </span>
</pre></div>
</div>
<div class="section" id="pyclaw-sharpclaw">
<h3><a class="toc-backref" href="#id4"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.sharpclaw</span></code></a><a class="headerlink" href="#pyclaw-sharpclaw" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver">
<em class="property">class </em><code class="sig-prename descclassname">pyclaw.sharpclaw.solver.</code><code class="sig-name descname">SharpClawSolver</code><span class="sig-paren">(</span><em class="sig-param">riemann_solver=None</em>, <em class="sig-param">claw_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass for all SharpClawND solvers.</p>
<p>Implements Runge-Kutta time stepping and the basic form of a 
semi-discrete step (the dq() function).  If another method-of-lines
solver is implemented in the future, it should be based on this class,
which then ought to be renamed to something like “MOLSolver”.</p>
<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.lim_type">
<code class="sig-name descname">lim_type</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.lim_type" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Limiter(s) to be used.</dt><dd><ul class="simple">
<li><p>0: No limiting.</p></li>
<li><p>1: TVD reconstruction.</p></li>
<li><p>2: WENO reconstruction.</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">2</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.weno_order">
<code class="sig-name descname">weno_order</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.weno_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Order of the WENO reconstruction. From 1st to 17th order (PyWENO)</p>
<p><code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">5</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.time_integrator">
<code class="sig-name descname">time_integrator</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.time_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Time integrator to be used. Currently implemented methods:</p>
<blockquote>
<div><ul>
<li><p>‘Euler’  : 1st-order Forward Euler integration</p></li>
<li><p>‘SSP33’  : 3rd-order strong stability preserving method of Shu &amp; Osher</p></li>
<li><p>‘SSP104’ : 4th-order strong stability preserving method Ketcheson</p></li>
<li><dl class="simple">
<dt>‘SSPLMM32’: 2nd-order strong stability preserving 3-step linear multistep method,</dt><dd><p>using Euler for starting values</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘SSPLMM43’: 3rd-order strong stability preserving 4-step linear multistep method</dt><dd><p>using SSPRK22 for starting values</p>
</dd>
</dl>
</li>
<li><dl>
<dt>‘RK’<span class="classifier">Arbitrary Runge-Kutta method, specified by setting <cite>solver.a</cite></span></dt><dd><p>and <cite>solver.b</cite> to the Butcher arrays of the method.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘LMM’<span class="classifier">Arbitrary linear multistep method, specified by setting the</span></dt><dd><p>coefficient arrays <cite>solver.alpha</cite> and <cite>solver.beta</cite>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">'SSP104'</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.char_decomp">
<code class="sig-name descname">char_decomp</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.char_decomp" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of WENO reconstruction.
0: conservative variables WENO reconstruction (standard).
1: Wave-slope reconstruction.
2: characteristic-wise WENO reconstruction.
3: transmission-based WENO reconstruction.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">0</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.tfluct_solver">
<code class="sig-name descname">tfluct_solver</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.tfluct_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a total fluctuation solver have to be used. If True the function
that calculates the total fluctuation must be provided.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.tfluct">
<code class="sig-name descname">tfluct</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.tfluct" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to Fortran routine to calculate total fluctuation
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">default_tfluct</span> <span class="pre">(None)</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.aux_time_dep">
<code class="sig-name descname">aux_time_dep</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.aux_time_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the auxiliary array is time dependent.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.kernel_language">
<code class="sig-name descname">kernel_language</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.kernel_language" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies whether to use wrapped Fortran routines (‘Fortran’)
or pure Python (‘Python’).  
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">'Fortran'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.num_ghost">
<code class="sig-name descname">num_ghost</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.num_ghost" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of ghost cells.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">3</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.fwave">
<code class="sig-name descname">fwave</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.fwave" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to split the flux jump (rather than the jump in Q) into waves; 
requires that the Riemann solver performs the splitting.  
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.cfl_desired">
<code class="sig-name descname">cfl_desired</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.cfl_desired" title="Permalink to this definition">¶</a></dt>
<dd><p>Desired CFL number.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">2.45</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.cfl_max">
<code class="sig-name descname">cfl_max</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.cfl_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum CFL number.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">2.50</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.dq_src">
<code class="sig-name descname">dq_src</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.dq_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a source term is present. If it is present the function that 
computes its contribution must be provided.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">None</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.call_before_step_each_stage">
<code class="sig-name descname">call_before_step_each_stage</code><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.call_before_step_each_stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to call the method <cite>self.before_step</cite> before each RK stage.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.accept_reject_step">
<code class="sig-name descname">accept_reject_step</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.accept_reject_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide whether to accept or not the current step.
For Runge-Kutta methods the step is accepted if cfl &lt;= cfl_max.
For SSPLMM32 the choice of step-size guarantees the cfl condition is satisfied for the steps the LMM
is used. Hence, we need to check the cfl condition only for the starting steps.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.check_3rd_ord_cond">
<code class="sig-name descname">check_3rd_ord_cond</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">step_index</em>, <em class="sig-param">dtFE</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.check_3rd_ord_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine checks the additional conditions for the 3rd-order SSPLMMs.
This is a posteriori check after a step is accepted.
In particular, there is a condition on the step size for the starting values and 
a condition on the ratio of forward Euler step sizes at very step.
If the conditions are violated we muct retrieve the previous solution and discard
that step; otherwise the step is accepted.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.dq">
<code class="sig-name descname">dq</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.dq" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate dq/dt * (delta t)</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.dqdt">
<code class="sig-name descname">dqdt</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.dqdt" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate dq/dt.  This routine is used for implicit time stepping.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.get_dt_new">
<code class="sig-name descname">get_dt_new</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.get_dt_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size of next step depending on the time integrator and
whether or not the current step was accepted.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">solution</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate RK stage arrays or previous step solutions and fortran routine work arrays.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param">solution</em>, <em class="sig-param">take_one_step</em>, <em class="sig-param">tstart</em>, <em class="sig-param">tend</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve q over one time step.</p>
<p>Take one step with a Runge-Kutta or multistep method as specified by
<cite>solver.time_integrator</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="pyclaw.sharpclaw.solver.SharpClawSolver.update_saved_values">
<code class="sig-name descname">update_saved_values</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">step_index</em><span class="sig-paren">)</span><a class="headerlink" href="#pyclaw.sharpclaw.solver.SharpClawSolver.update_saved_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates lists of saved function evaluations, solution values, dt and dtFE for LMMs.
For 3rd-order SSPLMM additional conditions are checked if self.check_lmm_cond is set to True.
If these conditions are violated, the step is rejected.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="pyclaw-classic-clawpack-solvers">
<span id="pyclaw-clawpack-solvers"></span><h2><a class="toc-backref" href="#id5">Pyclaw Classic Clawpack Solvers</a><a class="headerlink" href="#pyclaw-classic-clawpack-solvers" title="Permalink to this headline">¶</a></h2>
<p>The pyclaw classic clawpack solvers are a collection of solvers that represent
the functionality of the older versions of clawpack.  It comes in two forms, a
pure python version and a python wrapping of the fortran libraries.  All of the
solvers available provide the same basic interface and provide the same
options as the old versions of clawpack.  The superclass solvers are not meant
to be used separately but there to provide common routines for all the
Clawpack solvers.  Please refer to each of the inherited classes for more info
about the methods and attributes they provide each class.
.. The inheritance structure is:</p>
<dl class="field-list simple">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p>This is a simple example of how to instantiate and evolve a solution to a
later time <span class="math notranslate nohighlight">\(\text{t_end}\)</span> using the linearized 1d acoustics Riemann solver</p>
</dd>
</dl>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clawpack</span> <span class="kn">import</span> <span class="n">pyclaw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">pyclaw</span><span class="o">.</span><span class="n">ClawSolver1D</span><span class="p">()</span>                   <span class="c1"># Instantiate a default, 1d solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">limiters</span> <span class="o">=</span> <span class="n">pyclaw</span><span class="o">.</span><span class="n">limiters</span><span class="o">.</span><span class="n">tvd</span><span class="o">.</span><span class="n">vanleer</span>  <span class="c1"># Use the van Leer limiter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0001</span>                               <span class="c1"># Set the initial time step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">max_steps</span> <span class="o">=</span> <span class="mi">500</span>                           <span class="c1"># Set the maximum number of time steps</span>
</pre></div>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">evolve_to_time</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span><span class="n">t_end</span><span class="p">)</span>  <span class="c1"># Evolve the solution to t_end  </span>
</pre></div>
</div>
<div class="section" id="pyclaw-classic-solver">
<h3><a class="toc-backref" href="#id6"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.classic.solver</span></code></a><a class="headerlink" href="#pyclaw-classic-solver" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver">
<em class="property">class </em><code class="sig-prename descclassname">clawpack.pyclaw.classic.solver.</code><code class="sig-name descname">ClawSolver</code><span class="sig-paren">(</span><em class="sig-param">riemann_solver=None</em>, <em class="sig-param">claw_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic classic Clawpack solver</p>
<p>All Clawpack solvers inherit from this base class.</p>
<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.mthlim">
<code class="sig-name descname">mthlim</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.mthlim" title="Permalink to this definition">¶</a></dt>
<dd><p>Limiter(s) to be used.  Specified either as one value or a list.
If one value, the specified limiter is used for all wave families.
If a list, the specified values indicate which limiter to apply to
each wave family.  Take a look at pyclaw.limiters.tvd for an enumeration.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">limiters.tvd.minmod</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.order">
<code class="sig-name descname">order</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Order of the solver, either 1 for first order (i.e., Godunov’s method)
or 2 for second order (Lax-Wendroff-LeVeque).
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">2</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.source_split">
<code class="sig-name descname">source_split</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.source_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Which source splitting method to use: 1 for first 
order Godunov splitting and 2 for second order Strang splitting.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">1</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.fwave">
<code class="sig-name descname">fwave</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.fwave" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to split the flux jump (rather than the jump in Q) into waves; 
requires that the Riemann solver performs the splitting.  
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.step_source">
<code class="sig-name descname">step_source</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.step_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle for function that evaluates the source term.  
The required signature for this function is:</p>
<p>def step_source(solver,state,dt)</p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.kernel_language">
<code class="sig-name descname">kernel_language</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.kernel_language" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies whether to use wrapped Fortran routines (‘Fortran’)
or pure Python (‘Python’).  <code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">'Fortran'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.verbosity">
<code class="sig-name descname">verbosity</code><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.verbosity" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of detail of logged messages from the Fortran solver.
<code class="docutils literal notranslate"><span class="pre">Default</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">solution</em><span class="sig-paren">)</span><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform essential solver setup.  This routine must be called before
solver.step() may be called.</p>
</dd></dl>

<dl class="method">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param">solution</em>, <em class="sig-param">take_one_step</em>, <em class="sig-param">tstart</em>, <em class="sig-param">tend</em><span class="sig-paren">)</span><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve solution one time step</p>
<p>The elements of the algorithm for taking one step are:</p>
<ol class="arabic simple">
<li><p>Pick a step size as specified by the base solver attribute <code class="xref py py-func docutils literal notranslate"><span class="pre">get_dt()</span></code></p></li>
<li><p>A half step on the source term <a class="reference internal" href="#clawpack.pyclaw.classic.solver.ClawSolver.step_source" title="clawpack.pyclaw.classic.solver.ClawSolver.step_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">step_source()</span></code></a> if Strang splitting is 
being used (<a class="reference internal" href="#clawpack.pyclaw.classic.solver.ClawSolver.source_split" title="clawpack.pyclaw.classic.solver.ClawSolver.source_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source_split</span></code></a> = 2)</p></li>
<li><p>A step on the homogeneous problem <span class="math notranslate nohighlight">\(q_t + f(q)_x = 0\)</span> is taken</p></li>
<li><p>A second half step or a full step is taken on the source term
<a class="reference internal" href="#clawpack.pyclaw.classic.solver.ClawSolver.step_source" title="clawpack.pyclaw.classic.solver.ClawSolver.step_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">step_source()</span></code></a> depending on whether Strang splitting was used 
(<a class="reference internal" href="#clawpack.pyclaw.classic.solver.ClawSolver.source_split" title="clawpack.pyclaw.classic.solver.ClawSolver.source_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source_split</span></code></a> = 2) or Godunov splitting 
(<a class="reference internal" href="#clawpack.pyclaw.classic.solver.ClawSolver.source_split" title="clawpack.pyclaw.classic.solver.ClawSolver.source_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source_split</span></code></a> = 1)</p></li>
</ol>
<p>This routine is called from the method evolve_to_time defined in the
pyclaw.solver.Solver superclass.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><em>solution</em> - (<a class="reference internal" href="solution.html#pyclaw.solution.Solution" title="pyclaw.solution.Solution"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solution</span></code></a>) solution to be evolved</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p>(bool) - True if full step succeeded, False otherwise</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="clawpack.pyclaw.classic.solver.ClawSolver.step_hyperbolic">
<code class="sig-name descname">step_hyperbolic</code><span class="sig-paren">(</span><em class="sig-param">solution</em><span class="sig-paren">)</span><a class="headerlink" href="#clawpack.pyclaw.classic.solver.ClawSolver.step_hyperbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one homogeneous step on the solution.</p>
<p>This is a dummy routine and must be overridden.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p><a href="http://clawpack.org/">
    <img class="logo" src= "../_static/clawlogo.jpg" alt="Logo"/>
</a>
<h2>Version 5.1.0</h2>
</p>
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using PyClaw’s solvers: Classic and SharpClaw</a><ul>
<li><a class="reference internal" href="#sharpclaw-solvers">SharpClaw Solvers</a><ul>
<li><a class="reference internal" href="#pyclaw-sharpclaw"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.sharpclaw</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyclaw-classic-clawpack-solvers">Pyclaw Classic Clawpack Solvers</a><ul>
<li><a class="reference internal" href="#pyclaw-classic-solver"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyclaw.classic.solver</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">Pyclaw</a><ul>
  <li><a href="going_further.html">Going Further</a><ul>
      <li>Previous: <a href="clawpack_and_pyclaw.html" title="previous chapter">Porting a problem from Clawpack 4.6.x to PyClaw</a></li>
      <li>Next: <a href="parallel.html" title="next chapter">Running in parallel</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
<div class="widget navlinks">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/pyclaw/solvers.rst.txt"
            rel="nofollow"
            target="_blank">Source .rst</a></li>
    <li><a href="https://github.com/clawpack/doc/blob/dev/doc/pyclaw/solvers.rst"
            rel="nofollow"
            target="_blank">Source on GitHub</a></li>
     <li><a href="https://github.com/clawpack/doc/commits/dev/doc/pyclaw/solvers.rst"
             rel="nofollow"
             target="_blank">History</a></li>
    <li><a href="https://github.com/clawpack/doc/edit/dev/doc/pyclaw/solvers.rst"
            rel="nofollow"
            target="_blank">Suggest Edits</a></li>
     <li><a href="https://github.com/clawpack/doc/issues/new/choose"
             rel="nofollow"
             target="_blank">Raise an Issue</a></li>
  </ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<h4>Latest Version</h4>
<ul>
  <li><a href="../../dev/pyclaw/solvers.html">dev</a></li>
  <li><a href="../../v5.8.x/pyclaw/solvers.html">v5.8.x</a></li>
</ul>
<h4>Older Versions</h4>
<ul>
  <li><a href="solvers.html">v5.1.x</a></li>
  <li><a href="../../v5.2.x/pyclaw/solvers.html">v5.2.x</a></li>
  <li><a href="../../v5.3.x/pyclaw/solvers.html">v5.3.x</a></li>
  <li><a href="../../v5.4.x/pyclaw/solvers.html">v5.4.x</a></li>
  <li><a href="../../v5.5.x/pyclaw/solvers.html">v5.5.x</a></li>
  <li><a href="../../v5.6.x/pyclaw/solvers.html">v5.6.x</a></li>
  <li><a href="../../v5.7.x/pyclaw/solvers.html">v5.7.x</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright CC-BY 2022, The Clawpack Development Team.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44811544-1', 'auto');
  ga('send', 'pageview');

  </script>
  
  </body>
</html>