<!-- **** DO NOT EDIT THIS FILE *** 
         This file was generated automatically from file
              setrun.py
         using $CLAW/clawutil/src/python/clawutil/clawcode2html.py         -->

<html>
<title> setrun.py.html </title>


          <head>
           <link rel="icon" href="http://www.clawpack.org//_static/clawicon_new.ico" />
          </head> 
           <BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" 
                 VLINK="#5500DD" ALINK="#FF0000">
           <font FACE="HELVETICA,ARIAL">
           
<!-- Created from the file /Users/rjl/clawpack_src/clawpack_master/geoclaw/examples/bouss/radial_flat/setrun.py -->
<!-- Date: Sat Mar 23 2024 at 11:13:12 -->

<table bgcolor="#FFEE99"> <tr> <td>
&nbsp;<font size=6> setrun.py.html </font> </td>

            <td><a href="http://www.clawpack.org/index.html"><img
            src="http://www.clawpack.org//_static/clawlogo_border.jpg"
            width=150 alt="CLAWPACK"></a>&nbsp;&nbsp; </td> </tr> <tr> <td>
&nbsp;Source file: &nbsp;&nbsp;<a href="setrun.py">setrun.py </a>
</td></tr><tr><td>
&nbsp;Directory:  &nbsp; /Users/rjl/clawpack_src/clawpack_master/geoclaw/examples/bouss/radial_flat 
</td></tr><tr><td>
&nbsp;Converted:  &nbsp; Sat Mar 23 2024 at 11:13:12 
&nbsp; using <a href="http://www.clawpack.org//doc/application_documentation.html#clawcode2html">clawcode2html</a>
</td></tr><tr><td>
<font color="#BB3300"> &nbsp;This documentation file will 
not reflect any later changes in the source file. </font>
</td></tr></table></font>
<p>
<pre> 
"""
Module to set up run time parameters for Clawpack.

The values set in the function setrun are then written out to data files
that will be read in by the Fortran code.

"""

import os
import numpy as np

try:
    CLAW = os.environ['CLAW']
except:
    raise Exception("*** Must first set CLAW enviornment variable")

<font color="blue"># Scratch directory for storing topo and dtopo files:</font>
scratch_dir = os.path.join(CLAW, 'geoclaw', 'scratch')

<font color="blue"># used to create ruled rectangle:</font>
from clawpack.amrclaw import region_tools


<font color="blue">#------------------------------</font>
def setrun(claw_pkg='geoclaw'):
<font color="blue">#------------------------------</font>

    """
    Define the parameters used for running Clawpack.

    INPUT:
        claw_pkg expected to be "geoclaw" for this setrun.

    OUTPUT:
        rundata - object of class ClawRunData

    """

    from clawpack.clawutil import data

    assert claw_pkg.lower() == 'geoclaw',  "Expected claw_pkg = 'geoclaw'"

    num_dim = 2
    rundata = data.ClawRunData(claw_pkg, num_dim)


    <font color="blue">#------------------------------------------------------------------</font>
    <font color="blue"># Problem-specific parameters to be written to setprob.data:</font>
    <font color="blue">#------------------------------------------------------------------</font>
    
    <font color="blue">#probdata = rundata.new_UserData(name='probdata',fname='setprob.data')</font>


    <font color="blue">#------------------------------------------------------------------</font>
    <font color="blue"># GeoClaw specific parameters:</font>
    <font color="blue">#------------------------------------------------------------------</font>
    rundata = setgeo(rundata)

    <font color="blue">#------------------------------------------------------------------</font>
    <font color="blue"># Standard Clawpack parameters to be written to claw.data:</font>
    <font color="blue">#   (or to amr2ez.data for AMR)</font>
    <font color="blue">#------------------------------------------------------------------</font>
    clawdata = rundata.clawdata  <font color="blue"># initialized when rundata instantiated</font>


    <font color="blue"># Set single grid parameters first.</font>
    <font color="blue"># See below for AMR parameters.</font>


    <font color="blue"># ---------------</font>
    <font color="blue"># Spatial domain:</font>
    <font color="blue"># ---------------</font>

    <font color="blue"># Number of space dimensions:</font>
    clawdata.num_dim = num_dim

    <font color="blue"># Lower and upper edge of computational domain:</font>
    clawdata.lower[0] =   0.         <font color="blue"># xlower</font>
    clawdata.upper[0] = 5000.        <font color="blue"># xupper</font>
    clawdata.lower[1] =   0.         <font color="blue"># ylower</font>
    clawdata.upper[1] = 5000.        <font color="blue"># yupper</font>
    
    <font color="blue"># Number of grid cells:</font>
    clawdata.num_cells[0] = 100      <font color="blue"># mx</font>
    clawdata.num_cells[1] = 100      <font color="blue"># my</font>
    

    <font color="blue"># ---------------</font>
    <font color="blue"># Size of system:</font>
    <font color="blue"># ---------------</font>

    <font color="blue"># Number of equations in the system:</font>
    clawdata.num_eqn = 5

    <font color="blue"># Number of auxiliary variables in the aux array (initialized in setaux)</font>
    clawdata.num_aux = 1

    <font color="blue"># Index of aux array corresponding to capacity function, if there is one:</font>
    clawdata.capa_index = 0
    
    
    <font color="blue"># -------------</font>
    <font color="blue"># Initial time:</font>
    <font color="blue"># -------------</font>

    clawdata.t0 = 0.0


    <font color="blue"># Restart from checkpoint file of a previous run?</font>
    <font color="blue"># If restarting, t0 above should be from original run, and the</font>
    <font color="blue"># restart_file 'fort.chkNNNNN' specified below should be in </font>
    <font color="blue"># the OUTDIR indicated in Makefile.</font>

    clawdata.restart = False               <font color="blue"># True to restart from prior results</font>
    clawdata.restart_file = 'fort.chk00225'  <font color="blue"># File to use for restart data</font>
    
    
    <font color="blue"># -------------</font>
    <font color="blue"># Output times:</font>
    <font color="blue">#--------------</font>

    <font color="blue"># Specify at what times the results should be written to fort.q files.</font>
    <font color="blue"># Note that the time integration stops after the final output time.</font>
    <font color="blue"># The solution at initial time t0 is always written in addition.</font>

    clawdata.output_style = 1

    if clawdata.output_style==1:
        <font color="blue"># Output ntimes frames at equally spaced times up to tfinal:</font>
        <font color="blue"># Can specify num_output_times = 0 for no output</font>
        clawdata.num_output_times = 20
        clawdata.tfinal = 200.
        clawdata.output_t0 = True  <font color="blue"># output at initial (or restart) time?</font>
        
    elif clawdata.output_style == 2:
        <font color="blue"># Specify a list or numpy array of output times:</font>
        <font color="blue"># Include t0 if you want output at the initial time.</font>
        clawdata.output_times =  [251.] + list(np.arange(4.5, 17.1, 0.5)*60) 
        <font color="blue">#clawdata.output_times =  [251.] + list(np.arange(10,35,2)*60) </font>
            <font color="blue">#list(np.arange(35,48.5,0.5)*60)</font>
            <font color="blue">#list(np.arange(35,60.5,0.5)*60)</font>
        clawdata.output_t0 = True  <font color="blue"># output at initial (or restart) time?</font>
 
    elif clawdata.output_style == 3:
        <font color="blue"># Output every iout timesteps with a total of ntot time steps:</font>
        clawdata.output_step_interval = 1
        clawdata.total_steps = 10
        clawdata.output_t0 = True
        <font color="blue">#clawdata.output_t0 = False</font>
        

    clawdata.output_format = 'binary'      <font color="blue"># 'ascii' or 'binary' </font>

    clawdata.output_q_components = 'all'   <font color="blue"># need all</font>
    clawdata.output_aux_components = 'none'  <font color="blue"># eta=h+B is in q</font>
    clawdata.output_aux_onlyonce = False    <font color="blue"># output aux arrays each frame</font>



    <font color="blue"># ---------------------------------------------------</font>
    <font color="blue"># Verbosity of messages to screen during integration:</font>
    <font color="blue"># ---------------------------------------------------</font>

    <font color="blue"># The current t, dt, and cfl will be printed every time step</font>
    <font color="blue"># at AMR levels <= verbosity.  Set verbosity = 0 for no printing.</font>
    <font color="blue">#   (E.g. verbosity == 2 means print only on levels 1 and 2.)</font>
    clawdata.verbosity = 1



    <font color="blue"># --------------</font>
    <font color="blue"># Time stepping:</font>
    <font color="blue"># --------------</font>

    <font color="blue"># if dt_variable==1: variable time steps used based on cfl_desired,</font>
    <font color="blue"># if dt_variable==0: fixed time steps dt = dt_initial will always be used.</font>
    clawdata.dt_variable = True

    <font color="blue"># Initial time step for variable dt.</font>
    <font color="blue"># If dt_variable==0 then dt=dt_initial for all steps:</font>
    <font color="blue">#clawdata.dt_initial = .001</font>
    clawdata.dt_initial = .03

    <font color="blue"># Max time step to be allowed if variable dt used:</font>
    clawdata.dt_max = 1e+99

    <font color="blue"># Desired Courant number if variable dt used, and max to allow without</font>
    <font color="blue"># retaking step with a smaller dt:</font>
    clawdata.cfl_desired = 0.75
    clawdata.cfl_max = 1.0
    
    <font color="blue"># Maximum number of time steps to allow between output times:</font>
    clawdata.steps_max = 5000


    <font color="blue"># ------------------</font>
    <font color="blue"># Method to be used:</font>
    <font color="blue"># ------------------</font>

    <font color="blue"># Order of accuracy:  1 => Godunov,  2 => Lax-Wendroff plus limiters</font>
    clawdata.order = 2
    
    <font color="blue"># Use dimensional splitting? (not yet available for AMR)</font>
    clawdata.dimensional_split = 'unsplit'
    
    <font color="blue"># For unsplit method, transverse_waves can be </font>
    <font color="blue">#  0 or 'none'      ==> donor cell (only normal solver used)</font>
    <font color="blue">#  1 or 'increment' ==> corner transport of waves</font>
    <font color="blue">#  2 or 'all'       ==> corner transport of 2nd order corrections too</font>
    clawdata.transverse_waves = 2

    <font color="blue"># Number of waves in the Riemann solution:</font>
    clawdata.num_waves = 3
    
    <font color="blue"># List of limiters to use for each wave family:  </font>
    <font color="blue"># Required:  len(limiter) == num_waves</font>
    <font color="blue"># Some options:</font>
    <font color="blue">#   0 or 'none'     ==> no limiter (Lax-Wendroff)</font>
    <font color="blue">#   1 or 'minmod'   ==> minmod</font>
    <font color="blue">#   2 or 'superbee' ==> superbee</font>
    <font color="blue">#   3 or 'mc'       ==> MC limiter</font>
    <font color="blue">#   4 or 'vanleer'  ==> van Leer</font>
    clawdata.limiter = ['mc', 'mc', 'mc']
    <font color="blue">#clawdata.limiter = [0,0,0]</font>

    clawdata.use_fwaves = True    <font color="blue"># True ==> use f-wave version of algorithms</font>
    
    <font color="blue"># Source terms splitting:</font>
    <font color="blue">#   src_split == 0 or 'none'    ==> no source term (src routine never called)</font>
    <font color="blue">#   src_split == 1 or 'godunov' ==> Godunov (1st order) splitting used, </font>
    <font color="blue">#   src_split == 2 or 'strang'  ==> Strang (2nd order) splitting used,  not recommended.</font>
    clawdata.source_split = 'godunov'


    <font color="blue"># --------------------</font>
    <font color="blue"># Boundary conditions:</font>
    <font color="blue"># --------------------</font>

    <font color="blue"># Number of ghost cells (usually 2)</font>
    clawdata.num_ghost = 2

    <font color="blue"># Choice of BCs at xlower and xupper:</font>
    <font color="blue">#   0 or 'user'     => user specified (must modify bcNamr.f to use this option)</font>
    <font color="blue">#   1 or 'extrap'   => extrapolation (non-reflecting outflow)</font>
    <font color="blue">#   2 or 'periodic' => periodic (must specify this at both boundaries)</font>
    <font color="blue">#   3 or 'wall'     => solid wall for systems where q(2) is normal velocity</font>
    
    clawdata.bc_lower[0] = 'wall'   <font color="blue"># at xlower</font>
    clawdata.bc_upper[0] = 'extrap'   <font color="blue"># at xupper</font>

    clawdata.bc_lower[1] = 'wall'   <font color="blue"># at ylower</font>
    clawdata.bc_upper[1] = 'extrap'   <font color="blue"># at yupper</font>
                  
       
    <font color="blue"># ---------------</font>
    <font color="blue"># Gauges:</font>
    <font color="blue"># ---------------</font>

    gauges = rundata.gaugedata.gauges
    <font color="blue"># for gauges append lines of the form  [gaugeno, x, y, t1, t2]</font>

                  
    <font color="blue"># --------------</font>
    <font color="blue"># Checkpointing:</font>
    <font color="blue"># --------------</font>

    <font color="blue"># Specify when checkpoint files should be created that can be</font>
    <font color="blue"># used to restart a computation.</font>

    clawdata.checkpt_style = 1

    if clawdata.checkpt_style == 0:
        <font color="blue"># Do not checkpoint at all</font>
        pass

    elif np.abs(clawdata.checkpt_style) == 1:
        <font color="blue"># Checkpoint only at tfinal.</font>
        pass

    elif np.abs(clawdata.checkpt_style) == 2:
        <font color="blue"># Specify a list of checkpoint times.  </font>
        clawdata.checkpt_times = [0.1,0.15]

    elif np.abs(clawdata.checkpt_style) == 3:
        <font color="blue"># Checkpoint every checkpt_interval timesteps (on Level 1)</font>
        <font color="blue"># and at the final time.</font>
        clawdata.checkpt_interval = 50


    <font color="blue"># ---------------</font>
    <font color="blue"># AMR parameters:</font>
    <font color="blue"># ---------------</font>
    amrdata = rundata.amrdata

    <font color="blue"># maximum size of patches in each direction (matters in parallel):</font>
    amrdata.max1d = 60

    <font color="blue"># max number of refinement levels:</font>
    amrdata.amr_levels_max = 2

    <font color="blue"># List of refinement ratios at each level (length at least amr_level_max-1)</font>
    amrdata.refinement_ratios_x = [4,2]
    amrdata.refinement_ratios_y = [4,2]
    amrdata.refinement_ratios_t = [4,2]

    <font color="blue"># Specify type of each aux variable in amrdata.auxtype.</font>
    <font color="blue"># This must be a list of length num_aux, each element of which is one of:</font>
    <font color="blue">#   'center',  'capacity', 'xleft', or 'yleft'  (see documentation).</font>

    amrdata.aux_type = ['center']


    <font color="blue"># Flag using refinement routine flag2refine rather than richardson error</font>
    amrdata.flag_richardson = False    <font color="blue"># use Richardson?</font>
    amrdata.flag_richardson_tol = 1.0  <font color="blue"># Richardson tolerance</font>
    
    <font color="blue"># Flag for refinement using routine flag2refine:</font>
    amrdata.flag2refine = True      <font color="blue"># use this?</font>
    <font color="blue">#amrdata.flag2refine_tol = 0.5  # tolerance used in this routine</font>
    <font color="blue"># Note: in geoclaw the refinement tolerance is set as wave_tolerance below </font>
    <font color="blue"># and flag2refine_tol is unused!</font>

    <font color="blue"># steps to take on each level L between regriddings of level L+1:</font>
    amrdata.regrid_interval = 2

    <font color="blue"># width of buffer zone around flagged points:</font>
    <font color="blue"># (typically the same as regrid_interval so waves don't escape):</font>
    amrdata.regrid_buffer_width  = 3

    <font color="blue"># clustering alg. cutoff for (# flagged pts) / (total # of cells refined)</font>
    <font color="blue"># (closer to 1.0 => more small grids may be needed to cover flagged cells)</font>
    amrdata.clustering_cutoff = 0.7

    <font color="blue"># print info about each regridding up to this level:</font>
    amrdata.verbosity_regrid = 0      


    <font color="blue"># ---------------</font>
    <font color="blue"># AMR flagregions:</font>
    <font color="blue"># ---------------</font>

    flagregions = rundata.flagregiondata.flagregions  <font color="blue"># initialized to []</font>


    <font color="blue"># now append as many flagregions as desired to this list:</font>
    from clawpack.amrclaw.data import FlagRegion

    <font color="blue"># The entire domain restricted to level 1 for illustration:</font>
    <font color="blue"># Note that this is a rectangle specified in the new way:</font>
    <font color="blue"># (other regions below will force/allow more refinement)</font>
    flagregion = FlagRegion(num_dim=2)
    flagregion.name = 'Region_domain'
    flagregion.minlevel = 1
    flagregion.maxlevel = 1
    flagregion.t1 = 0.
    flagregion.t2 = 1e9
    flagregion.spatial_region_type = 1  <font color="blue"># Rectangle</font>
    flagregion.spatial_region = [clawdata.lower[0], clawdata.upper[0], \
                                 clawdata.lower[1], clawdata.upper[1]]
    flagregions.append(flagregion)

    <font color="blue"># A ruled rectangle covering abs(x-y) < 1000:</font>
    flagregion = FlagRegion(num_dim=2)
    flagregion.name = 'Region_diagonal'
    flagregion.minlevel = 1
    flagregion.maxlevel = 2
    flagregion.t1 = 0.
    flagregion.t2 = 1e9
    flagregion.spatial_region_type = 2  <font color="blue"># Ruled Rectangle</font>
    flagregion.spatial_region_file = \
            os.path.abspath('RuledRectangle_Diagonal.data')
    flagregions.append(flagregion)

    <font color="blue"># code to make RuledRectangle_Diagonal.data:</font>
    rr = region_tools.RuledRectangle()
    rr.method = 1 <font color="blue"># piecewiselinear edges between s values</font>
    rr.ixy = 'x'  <font color="blue"># so s refers to x, lower & upper are limits in y</font>
    rr.s = np.array([0, 5000.])
    rr.lower = np.array([-1000, 4000.])
    rr.upper = np.array([1000., 6000.])
    rr.write('RuledRectangle_Diagonal.data')

    <font color="blue"># Region near the origin where level 3 is allowed:</font>
    flagregion = FlagRegion(num_dim=2)
    flagregion.name = 'Region_domain'
    flagregion.minlevel = 1
    flagregion.maxlevel = 3
    flagregion.t1 = 0.
    flagregion.t2 = 1e9
    flagregion.spatial_region_type = 1  <font color="blue"># Rectangle</font>
    flagregion.spatial_region = [0,1000,0,1000]
    flagregions.append(flagregion)


    <font color="blue"># A ruled rectangle covering abs(x-y) < 1000 for x,y < 2000:</font>
    <font color="blue"># Only relevant if amr_levels_max >= 3 to capture trailing waves better</font>
    flagregion = FlagRegion(num_dim=2)
    flagregion.name = 'Region_diagonal2'
    flagregion.minlevel = 1
    flagregion.maxlevel = 3
    flagregion.t1 = 0.
    flagregion.t2 = 1e9
    flagregion.spatial_region_type = 2  <font color="blue"># Ruled Rectangle</font>
    flagregion.spatial_region_file = \
            os.path.abspath('RuledRectangle_Diagonal2.data')
    <font color="blue">#flagregions.append(flagregion)</font>


    <font color="blue"># code to make RuledRectangle_Diagonal2.data:</font>
    rr = region_tools.RuledRectangle()
    rr.method = 1 <font color="blue"># piecewiselinear edges between s values</font>
    rr.ixy = 'x'  <font color="blue"># so s refers to x, lower & upper are limits in y</font>
    rr.s = np.array([0, 1000., 2000.])
    rr.lower = np.array([0, 0, 2000.])
    rr.upper = np.array([1000., 2000., 2000.])
    rr.write('RuledRectangle_Diagonal2.data')

    <font color="blue">#  ----- For developers ----- </font>
    <font color="blue"># Toggle debugging print statements:</font>
    amrdata.dprint = False      <font color="blue"># print domain flags</font>
    amrdata.eprint = False      <font color="blue"># print err est flags</font>
    amrdata.edebug = False      <font color="blue"># even more err est flags</font>
    amrdata.gprint = False      <font color="blue"># grid bisection/clustering</font>
    amrdata.nprint = False      <font color="blue"># proper nesting output</font>
    amrdata.pprint = False      <font color="blue"># proj. of tagged points</font>
    amrdata.rprint = False      <font color="blue"># print regridding summary</font>
    amrdata.sprint = False      <font color="blue"># space/memory output</font>
    amrdata.tprint = False      <font color="blue"># time step reporting each level</font>
    amrdata.uprint = False      <font color="blue"># update/upbnd reporting</font>
    
    return rundata
    <font color="blue"># end of function setrun</font>
    <font color="blue"># ----------------------</font>


<font color="blue">#-------------------</font>
def setgeo(rundata):
<font color="blue">#-------------------</font>
    """
    Set GeoClaw specific runtime parameters.
    """

    try:
        geo_data = rundata.geo_data
    except:
        print("*** Error, this rundata has no geo_data attribute")
        raise AttributeError("Missing geo_data attribute")

    <font color="blue"># == Physics ==</font>
    geo_data.gravity = 9.81
    geo_data.coordinate_system =  1
    geo_data.earth_radius = 6367500.0

    <font color="blue"># == Forcing Options</font>
    geo_data.coriolis_forcing = False

    <font color="blue"># == Algorithm and Initial Conditions ==</font>
    geo_data.sea_level = 0.0
    geo_data.dry_tolerance = 1.e-3
    geo_data.friction_forcing = True
    geo_data.manning_coefficient = 0.025
    geo_data.friction_depth = 100.0

    <font color="blue"># Refinement settings</font>
    refinement_data = rundata.refinement_data
    refinement_data.variable_dt_refinement_ratios = True
    refinement_data.wave_tolerance = 0.02

    <font color="blue"># == settopo.data values ==</font>


    topofiles = rundata.topo_data.topofiles
    <font color="blue"># for topography, append lines of the form</font>
    <font color="blue">#    [topotype, fname]</font>

    topofiles.append([1, 'flat100.tt1'])


    <font color="blue"># == setdtopo.data values ==</font>
    dtopo_data = rundata.dtopo_data
    <font color="blue"># for moving topography, append lines of the form :   (<= 1 allowed for now!)</font>
    <font color="blue">#   [topotype, fname]</font>


    <font color="blue"># == setqinit.data values ==</font>
    rundata.qinit_data.qinit_type =  0
    rundata.qinit_data.qinitfiles = []
    qinitfiles = rundata.qinit_data.qinitfiles 
    <font color="blue"># for qinit perturbations, append lines of the form: (<= 1 allowed for now!)</font>
    <font color="blue">#   [minlev, maxlev, fname]</font>


    <font color="blue"># To use Boussinesq solver, add bouss_data parameters here</font>
    <font color="blue"># Also make sure to use the correct Makefile pointing to bouss version</font>
    <font color="blue"># and set clawdata.num_eqn = 5</font>

    from clawpack.geoclaw.data import BoussData
    rundata.add_data(BoussData(),'bouss_data')
    
    rundata.bouss_data.bouss_equations = 2    <font color="blue"># 0=SWE, 1=MS, 2=SGN</font>
    rundata.bouss_data.bouss_min_level = 1    <font color="blue"># coarsest level to apply bouss</font>
    rundata.bouss_data.bouss_max_level = 10   <font color="blue"># finest level to apply bouss</font>
    rundata.bouss_data.bouss_min_depth = 1.  <font color="blue"># depth to switch to SWE</font>
    rundata.bouss_data.bouss_solver = 3       <font color="blue"># 1=GMRES, 2=Pardiso, 3=PETSc</font>
    rundata.bouss_data.bouss_tstart = 0.      <font color="blue"># time to switch from SWE</font>

    return rundata
    <font color="blue"># end of function setgeo</font>
    <font color="blue"># ----------------------</font>



if __name__ == '__main__':
    <font color="blue"># Set up run-time parameters and write all data files.</font>
    import sys
    <font color="blue">#from clawpack.geoclaw import kmltools</font>

    rundata = setrun(*sys.argv[1:])
    rundata.write()

    <font color="blue">#kmltools.make_input_data_kmls(rundata)</font>
</pre></html>
