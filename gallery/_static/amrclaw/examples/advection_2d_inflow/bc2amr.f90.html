<!-- **** DO NOT EDIT THIS FILE *** 
         This file was generated automatically from file
              bc2amr.f90
         using $CLAW/clawutil/src/python/clawutil/clawcode2html.py         -->

<html>
<title> bc2amr.f90.html </title>


          <head>
           <link rel="icon" href="http://www.clawpack.org//_static/clawicon_new.ico" />
          </head> 
           <BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" 
                 VLINK="#5500DD" ALINK="#FF0000">
           <font FACE="HELVETICA,ARIAL">
           
<!-- Created from the file /Users/rjl/clawpack_src/clawpack_master/amrclaw/examples/advection_2d_inflow/bc2amr.f90 -->
<!-- Date: Thu Apr 23 2020 at 19:57:39 -->

<table bgcolor="#FFEE99"> <tr> <td>
&nbsp;<font size=6> bc2amr.f90.html </font> </td>

            <td><a href="http://www.clawpack.org/index.html"><img
            src="http://www.clawpack.org//_static/clawlogo_border.jpg"
            width=150 alt="CLAWPACK"></a>&nbsp;&nbsp; </td> </tr> <tr> <td>
&nbsp;Source file: &nbsp;&nbsp;<a href="bc2amr.f90">bc2amr.f90 </a>
</td></tr><tr><td>
&nbsp;Directory:  &nbsp; /Users/rjl/clawpack_src/clawpack_master/amrclaw/examples/advection_2d_inflow 
</td></tr><tr><td>
&nbsp;Converted:  &nbsp; Thu Apr 23 2020 at 19:57:39 
&nbsp; using <a href="http://www.clawpack.org//doc/application_documentation.html#clawcode2html">clawcode2html</a>
</td></tr><tr><td>
<font color="#BB3300"> &nbsp;This documentation file will 
not reflect any later changes in the source file. </font>
</td></tr></table></font>
<p>
<pre> 
<font color="blue">! :::::::::: bc2amr ::::::::::::::::::::::::::::::::::::::::::::::;</font>
<font color="blue">!> \callgraph</font>
<font color="blue">!! \callergraph</font>
<font color="blue">!!  Take a grid patch with mesh widths **hx**,**hy**, of dimensions **nrow** by</font>
<font color="blue">!!  **ncol**,  and set the values of any piece of</font>
<font color="blue">!!  of the patch which extends outside the physical domain </font>
<font color="blue">!!  using the boundary conditions. </font>
<font color="blue">!!</font>
<font color="blue">!!  ### Standard boundary condition choices for amr2ez in clawpack</font>
<font color="blue">!!</font>
<font color="blue">!!  At each boundary  k = 1 (left),  2 (right),  3 (bottom), 4 (top):</font>
<font color="blue">!!</font>
<font color="blue">!!  mthbc(k) =  </font>
<font color="blue">!!  * 0  for user-supplied BC's (must be inserted!)</font>
<font color="blue">!!  * 1  for zero-order extrapolation</font>
<font color="blue">!!  * 2  for periodic boundary conditions</font>
<font color="blue">!!  * 3  for solid walls, assuming this can be implemented</font>
<font color="blue">!!                   by reflecting the data about the boundary and then</font>
<font color="blue">!!                   negating the 2'nd (for k=1,2) or 3'rd (for k=3,4)</font>
<font color="blue">!!                   component of q.</font>
<font color="blue">!!  * 4  for sphere bcs (left half maps to right half of same side, and vice versa), as if domain folded in half</font>
<font color="blue">!!</font>
<font color="blue">!!  The corners of the grid patch are at </font>
<font color="blue">!!     (xlo_patch,ylo_patch)  --  lower left corner</font>
<font color="blue">!!     (xhi_patch,yhi_patch) --  upper right corner</font>
<font color="blue">!!</font>
<font color="blue">!!  The physical domain itself is a rectangle bounded by</font>
<font color="blue">!!     (xlower,ylower)  -- lower left corner</font>
<font color="blue">!!     (xupper,yupper)  -- upper right corner</font>
<font color="blue">!!  </font>
<font color="blue">!   This figure below does not work with doxygen</font>
<font color="blue">!   the picture is the following: </font>
<font color="blue">!  ____________________________________________________</font>
<font color="blue">! </font>
<font color="blue">!                _____________________ (xupper,yupper)</font>
<font color="blue">!               |                     |  </font>
<font color="blue">!           ____|____ (xhi_patch,yhi_patch)   </font>
<font color="blue">!           |   |    |                |</font>
<font color="blue">!           |   |    |                |</font>
<font color="blue">!           |   |    |                |</font>
<font color="blue">!           |___|____|                |</font>
<font color="blue">!  (xlo_patch,ylo_patch) |            |</font>
<font color="blue">!               |                     |</font>
<font color="blue">!               |_____________________|   </font>
<font color="blue">!    (xlower,ylower)</font>
<font color="blue">!  ____________________________________________________</font>
<font color="blue">!!</font>
<font color="blue">!!</font>
<font color="blue">!>  Any cells that lie outside the physical domain are ghost cells whose</font>
<font color="blue">!!  values should be set in this routine.  This is tested for by comparing</font>
<font color="blue">!!  xlo_patch with xlower to see if values need to be set at the left</font>
<font color="blue">!   as in the figure above, </font>
<font color="blue">!</font>
<font color="blue">!>  and similarly at the other boundaries.</font>
<font color="blue">!!  Patches are guaranteed to have at least 1 row of cells filled</font>
<font color="blue">!!  with interior values so it is possible to extrapolate. </font>
<font color="blue">!!  Fix [trimbd()](@ref trimbd) if you want more than 1 row pre-set.</font>
<font color="blue">!!</font>
<font color="blue">!!  Make sure the order the boundaries are specified is correct</font>
<font color="blue">!!  so that diagonal corner cells are also properly taken care of.</font>
<font color="blue">!!</font>
<font color="blue">!!  Periodic boundaries are set before calling this routine, so if the</font>
<font color="blue">!!  domain is periodic in one direction only you</font>
<font color="blue">!!  can safely extrapolate in the other direction. </font>
<font color="blue">!!</font>
<font color="blue">!!  Don't overwrite ghost cells in periodic directions!</font>
<font color="blue">!!</font>
<font color="blue">!! \param val data array for solution \f$q \f$ (cover the whole grid **msrc**)</font>
<font color="blue">!! \param aux data array for auxiliary variables </font>
<font color="blue">!! \param nrow number of cells in *i* direction on this grid</font>
<font color="blue">!! \param ncol number of cells in *j* direction on this grid</font>
<font color="blue">!! \param meqn number of equations for the system</font>
<font color="blue">!! \param naux number of auxiliary variables</font>
<font color="blue">!! \param hx spacing (mesh size) in *i* direction</font>
<font color="blue">!! \param hy spacing (mesh size) in *j* direction</font>
<font color="blue">!! \param level AMR level of this grid</font>
<font color="blue">!! \param time setting ghost cell values at time **time**</font>
<font color="blue">!! \param xlo_patch left bound of the input grid</font>
<font color="blue">!! \param xhi_patch right bound of the input grid </font>
<font color="blue">!! \param ylo_patch lower bound of the input grid </font>
<font color="blue">!! \param yhi_patch upper bound of the input grid </font>
<font color="blue">! ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;</font>

subroutine bc2amr(val,aux,nrow,ncol,meqn,naux, hx, hy, level, time,   &
                  xlo_patch, xhi_patch, ylo_patch, yhi_patch) 

    use amr_module, only: mthbc, xlower, ylower, xupper, yupper
    use amr_module, only: xperdom, yperdom, spheredom

    implicit none

    <font color="blue">! Input/Output</font>
    integer, intent(in) :: nrow, ncol, meqn, naux, level
    real(kind=8), intent(in) :: hx, hy, time
    real(kind=8), intent(in) :: xlo_patch, xhi_patch
    real(kind=8), intent(in) :: ylo_patch, yhi_patch
    real(kind=8), intent(in out) :: val(meqn, nrow, ncol)
    real(kind=8), intent(in out) :: aux(naux, nrow, ncol)
    
    <font color="blue">! Local storag</font>
    integer :: i, j, ibeg, jbeg, nxl, nxr, nyb, nyt
    real(kind=8) :: hxmarg, hymarg

    <font color="blue">! Inflow boundary condition variables</font>
    real(kind=8) :: x, y, tau, x0, y0

    <font color="blue">! True solution for BCs</font>
    interface
        real(kind=8) pure function qtrue(x, y ,t)
            implicit none
            real(kind=8), intent(in) :: x, y ,t
        end function qtrue
    end interface

    <font color="blue">! Common block parameters</font>
    real(kind=8) :: ubar, vbar
    common /cparam/ ubar, vbar

    hxmarg = hx * .01d0
    hymarg = hy * .01d0

    <font color="blue">! Use periodic boundary condition specialized code only, if only one </font>
    <font color="blue">! boundary is periodic we still proceed below</font>
    if (xperdom .and. (yperdom .or. spheredom)) then
        return
    end if

    <font color="blue">! Each check has an initial check to ensure that the boundary is a real</font>
    <font color="blue">! boundary condition and otherwise skips the code.  Otherwise </font>
    <font color="blue">!-------------------------------------------------------</font>
    <font color="blue">! Left boundary:</font>
    <font color="blue">!-------------------------------------------------------</font>
    if (xlo_patch < xlower-hxmarg) then
        <font color="blue">! number of grid cells from this patch lying outside physical domain:</font>
        nxl = int((xlower + hxmarg - xlo_patch) / hx)

        select case(mthbc(1))
            case(0) <font color="blue">! User defined boundary condition</font>
                <font color="blue">! Inflow boundary condition</font>
                if (ubar < 0.1d0 * vbar) then
                    stop "Inflow BCs at left boundary assume ubar >= vbar / 10"
                end if

                do j = 1, ncol
                    y = ylo_patch + (j - 0.5d0) * hy
                    if (nxl >= 1) then
                        <font color="blue">! First ghost cell</font>
                        tau = hx / (2.d0 * ubar)
                        val(1,nxl,j) = qtrue(0.d0, y + vbar * tau, time + tau)
                    end if
                    if (nxl == 2) then
                        <font color="blue">! second ghost cell:</font>
                        tau = 3.d0 * hx / (2.d0 * ubar)
                        val(1,1,j) = qtrue(0.d0, y + vbar * tau, time + tau)
                    end if
                end do

            case(1) <font color="blue">! Zero-order extrapolation</font>
                do j = 1, ncol
                    do i=1, nxl
                        val(:, i, j) = val(:, nxl + 1, j)
                    end do
                end do

            case(2) <font color="blue">! Periodic boundary condition</font>
                continue

            case(3) <font color="blue">! Wall boundary conditions</font>
                do j = 1, ncol
                    do i=1, nxl
                        val(:, i, j) = val(:, 2 * nxl + 1 - i, j)
                    end do
                end do
                <font color="blue">! negate the normal velocity:</font>
                do j = 1, ncol
                    do i=1, nxl
                        val(2, i, j) = -val(2, i, j)
                    end do
                end do

            case(4) <font color="blue">! Spherical domain</font>
                continue

            case default
                print *, "Invalid boundary condition requested."
                stop
        end select
    end if

    <font color="blue">!-------------------------------------------------------</font>
    <font color="blue">! Right boundary:</font>
    <font color="blue">!-------------------------------------------------------</font>
    if (xhi_patch > xupper+hxmarg) then

        <font color="blue">! number of grid cells lying outside physical domain:</font>
        nxr = int((xhi_patch - xupper + hxmarg) / hx)
        ibeg = max(nrow - nxr + 1, 1)

        select case(mthbc(2))
            case(0) <font color="blue">! User defined boundary condition</font>
                <font color="blue">! Replace this code with a user defined boundary condition</font>
                stop "A user defined boundary condition was not provided."
            case(1) <font color="blue">! Zero-order extrapolation</font>
                do i = ibeg, nrow
                    do j = 1, ncol
                        val(:, i, j) = val(:, ibeg - 1, j)
                    end do
                end do

            case(2) <font color="blue">! Periodic boundary condition</font>
                continue

            case(3) <font color="blue">! Wall boundary conditions</font>
                do i=ibeg, nrow
                    do j = 1, ncol
                        val(:, i, j) = val(:, 2 * ibeg - 1 - i, j)
                    end do
                end do
                <font color="blue">! negate the normal velocity:</font>
                do i = ibeg, nrow
                    do j = 1, ncol
                        val(2, i, j) = -val(2, i, j)
                    end do
                end do

            case(4) <font color="blue">! Spherical domain</font>
                continue

            case default
                print *, "Invalid boundary condition requested."
                stop

        end select
    end if

    <font color="blue">!-------------------------------------------------------</font>
    <font color="blue">! Bottom boundary:</font>
    <font color="blue">!-------------------------------------------------------</font>
    if (ylo_patch < ylower - hymarg) then

        <font color="blue">! number of grid cells lying outside physical domain:</font>
        nyb = int((ylower + hymarg - ylo_patch) / hy)

        select case(mthbc(3))
            case(0) <font color="blue">! User defined boundary condition</font>
                <font color="blue">! Inflow boundary condition</font>
                if (vbar < 0.1d0 * ubar) then
                    stop "Inflow BCs at bottom boundary assume vbar >= ubar / 10"
                end if

                do i = 1, nrow
                    x = xlo_patch + (i - 0.5d0) * hx
                    if (nyb >= 1) then
                        <font color="blue">! First ghost cell</font>
                        tau = hy / (2.d0 * vbar)
                        val(1,i,nyb) = qtrue(x + vbar * tau, 0.d0, time + tau)
                    end if
                    if (nyb == 2) then
                        <font color="blue">! second ghost cell:</font>
                        tau = 3.d0 * hy / (2.d0 * vbar)
                        val(1,i,1) = qtrue(x + ubar * tau, 0.d0, time + tau)
                    end if
                end do

            case(1) <font color="blue">! Zero-order extrapolation</font>
                do j = 1, nyb
                    do i = 1, nrow
                        val(:,i,j) = val(:, i, nyb + 1)
                    end do
                end do

            case(2) <font color="blue">! Periodic boundary condition</font>
                continue

            case(3) <font color="blue">! Wall boundary conditions</font>
                do j = 1, nyb
                    do i = 1, nrow
                        val(:,i,j) = val(:, i, 2 * nyb + 1 - j)
                    end do
                end do
                <font color="blue">! negate the normal velocity:</font>
                do j = 1, nyb
                    do i = 1, nrow
                        val(3,i,j) = -val(3, i, j)
                    end do
                end do

            case(4) <font color="blue">! Spherical domain</font>
                continue

            case default
                print *, "Invalid boundary condition requested."
                stop

        end select
    end if

    <font color="blue">!-------------------------------------------------------</font>
    <font color="blue">! Top boundary:</font>
    <font color="blue">!-------------------------------------------------------</font>
    if (yhi_patch > yupper + hymarg) then

        <font color="blue">! number of grid cells lying outside physical domain:</font>
        nyt = int((yhi_patch - yupper + hymarg) / hy)
        jbeg = max(ncol - nyt + 1, 1)

        select case(mthbc(4))
            case(0) <font color="blue">! User defined boundary condition</font>
                <font color="blue">! Replace this code with a user defined boundary condition</font>
                stop "A user defined boundary condition was not provided."

            case(1) <font color="blue">! Zero-order extrapolation</font>
                do j = jbeg, ncol
                    do i = 1, nrow
                        val(:, i, j) = val(:, i, jbeg - 1)
                    end do
                end do

            case(2) <font color="blue">! Periodic boundary condition</font>
                continue

            case(3) <font color="blue">! Wall boundary conditions</font>
                do j = jbeg, ncol 
                    do i = 1, nrow
                        val(:, i, j) = val(:, i, 2 * jbeg - 1 - j)
                    end do
                end do
                <font color="blue">! negate the normal velocity:</font>
                do j = jbeg, ncol
                    do i = 1, nrow
                        val(3, i, j) = -val(3, i, j)
                    end do
                end do

            case(4) <font color="blue">! Spherical domain</font>
                continue

            case default
                print *, "Invalid boundary condition requested."
                stop

        end select
    end if

end subroutine bc2amr</pre></html>
